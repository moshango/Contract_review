# 合同审查系统架构优化 - 统一工作流设计方案

**状态**: 🔄 架构设计完成
**日期**: 2025-10-27
**目标**: 消除代码重复，建立统一的审查接口，防止问题复现

---

## 📊 现状问题分析

### 当前架构的问题

1. **三套并行的审查工作流**
   - 规则审查 (Rule Review)
   - ChatGPT集成 (ChatGPT Web)
   - 一键审查 (One-Click Review)
   - 它们分别实现了相同的解析、缓存、批注流程

2. **前后端代码重复严重**
   - 前端：5个相同的文件选择处理器，4个复制功能，10+处加载动画操作
   - 后端：3处相同的合同解析，2处Prompt生成，2处批注逻辑

3. **状态管理混乱**
   - `ruleReviewParseResultId` vs `window.currentParseResultId` vs `chatgptParseResultId`
   - 导致parseResultId丢失和批注缺少锚点

4. **接口冗余**
   - `/api/review/analyze` - 生成规则Prompt
   - `/chatgpt/generate-prompt` - 生成ChatGPT Prompt
   - `/api/qwen/rule-review/one-click-review` - 一键端到端
   - 都包含重复的解析、缓存步骤

---

## 🎯 统一架构设计

### 核心设计原则

```
一个文件 + 一个工作流 = 多种审查方式
```

不同的审查方式（规则、ChatGPT、Qwen）应该是**同一个工作流的不同配置**，而不是完全独立的三个流程。

### 统一工作流模型

```
┌─────────────────────────────────────────────────────────────────┐
│                   统一的审查工作流                                │
└─────────────────────────────────────────────────────────────────┘

┌─ 阶段1：准备 ──────────────────────────────────────────────────┐
│                                                                   │
│  1.1 选择合同文件                                                 │
│  1.2 选择审查方式（规则/ChatGPT/Qwen一键）                        │
│  1.3 选择审查立场（甲方/乙方）                                    │
│                                                                   │
│  ✅ 统一的输入验证                                                │
│  ✅ 统一的文件选择处理                                            │
│  ✅ 统一的参数管理                                                │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘

         ↓ ReviewRequest { file, mode, stance }

┌─ 阶段2：解析 ──────────────────────────────────────────────────┐
│                                                                   │
│  2.1 解析合同文件（带锚点）                                       │
│  2.2 提取甲乙方信息（Qwen/规则）                                  │
│  2.3 识别合同类型                                                │
│  2.4 缓存 parseResultId（用于后续批注）                           │
│                                                                   │
│  ✅ 统一的解析服务 (ReviewParsingService)                         │
│  ✅ 统一的缓存管理 (ParseResultCache)                            │
│  ✅ 统一的结果结构 (ReviewContext)                               │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘

    ↓ ReviewContext { file, anchors, partyA/B, contractType, parseResultId }

┌─ 阶段3：分析 ──────────────────────────────────────────────────┐
│                                                                   │
│  根据审查方式（mode）执行不同的分析逻辑                           │
│                                                                   │
│  3.1 规则审查模式 (RULE_REVIEW)                                   │
│      3.1.1 应用本地规则进行匹配                                    │
│      3.1.2 生成规则审查Prompt                                      │
│      3.1.3 返回规则匹配结果（等待用户下一步）                      │
│                                                                   │
│  3.2 ChatGPT模式 (CHATGPT)                                        │
│      3.2.1 生成ChatGPT Prompt                                      │
│      3.2.2 返回Prompt（用户手动复制到ChatGPT）                     │
│                                                                   │
│  3.3 Qwen一键审查模式 (QWEN_AUTO)                                 │
│      3.3.1 应用本地规则进行匹配                                    │
│      3.3.2 生成规则审查Prompt                                      │
│      3.3.3 调用Qwen进行AI审查                                      │
│      3.3.4 解析Qwen审查结果                                        │
│      3.3.5 执行批注                                                │
│      3.3.6 保存文档                                                │
│      3.3.7 返回文档                                                │
│                                                                   │
│  ✅ 统一的分析框架 (ReviewAnalysisService)                        │
│  ✅ 模式隔离 (ReviewMode enum)                                    │
│  ✅ 条件执行 (strategy pattern)                                   │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘

         ↓ ReviewAnalysisResult { mode, analysisData, ... }

┌─ 阶段4：后处理 ────────────────────────────────────────────────┐
│                                                                   │
│  4.1 导入外部LLM审查结果 (ChatGPT、其他)                           │
│      4.1.1 验证结果格式                                           │
│      4.1.2 使用缓存的parseResultId获取带锚点文档                  │
│      4.1.3 执行批注                                               │
│      4.1.4 保存文档                                               │
│                                                                   │
│  4.2 规则审查直接批注（从阶段3跳过来）                            │
│      4.2.1 导入规则审查结果                                       │
│      4.2.2 执行批注                                               │
│      4.2.3 保存文档                                               │
│                                                                   │
│  ✅ 统一的批注服务 (ReviewAnnotationService)                     │
│  ✅ 统一的文档保存 (ReviewDocumentSaver)                         │
│                                                                   │
└─────────────────────────────────────────────────────────────────┘

              ↓ ReviewOutput { status, document, ... }
```

### 关键创新：ReviewContext

```java
/**
 * 统一的审查上下文，贯穿整个工作流
 * 作用：确保parseResultId在整个流程中持续有效
 */
public class ReviewContext {
    // 阶段1：输入
    private MultipartFile file;
    private ReviewMode mode;  // RULE_REVIEW, CHATGPT, QWEN_AUTO
    private String stance;    // A 或 B

    // 阶段2：解析结果
    private ParseResult parseResult;
    private byte[] documentWithAnchors;
    private String parseResultId;  // ← 关键：在这里统一管理
    private String partyA;
    private String partyB;
    private String contractType;

    // 阶段3：分析结果
    private ReviewAnalysisResult analysisResult;

    // 阶段4：最终结果
    private byte[] annotatedDocument;
    private boolean success;

    // 工具方法
    public void cacheParseResult(String id, byte[] docBytes) {
        this.parseResultId = id;
        this.documentWithAnchors = docBytes;
    }

    public String getParseResultIdForAnnotation() {
        return this.parseResultId;  // 确保批注使用的是同一个ID
    }
}
```

### API 设计

**原来的接口：**
```
规则审查：POST /api/review/extract-parties
        POST /api/review/analyze
        POST /chatgpt/import-result

ChatGPT： POST /chatgpt/generate-prompt
        POST /chatgpt/import-result

一键审查：POST /api/qwen/rule-review/one-click-review
```

**统一后的接口：**
```
POST /api/review/start
  └─ ReviewRequest { file, mode (RULE/CHATGPT/QWEN_AUTO), stance }
  ├─ mode=RULE_REVIEW     → 返回匹配结果 + Prompt
  ├─ mode=CHATGPT         → 返回Prompt
  └─ mode=QWEN_AUTO       → 返回完整的批注文档

POST /api/review/import-result
  └─ ReviewResultRequest { parseResultId, mode, analysisResult }
  └─ 返回批注后的文档

GET /api/review/status
  └─ 检查服务状态（规则库、Qwen、缓存等）
```

**向后兼容的接口：**
```
保留原有接口但重定向到新接口：

POST /api/review/extract-parties → 调用 ReviewAnalysisService.extractParties()
POST /api/review/analyze → 调用 ReviewAnalysisService.analyzeWithRules()
POST /chatgpt/generate-prompt → 调用 ReviewAnalysisService.analyzeWithoutRules()
POST /chatgpt/import-result → 调用 ReviewAnnotationService.importResult()
POST /api/qwen/rule-review/one-click-review → 调用 ReviewAnalysisService.analyzeAutomatic()
```

---

## 🏗️ 实现架构

### 前端架构

```
src/main/resources/static/js/
│
├─ main.js (统一的审查入口)
│  ├─ ReviewController (类) - 统一的业务逻辑
│  │  ├─ startReview(file, mode, stance)
│  │  ├─ handleAnalysisResult(result)
│  │  ├─ importReviewResult(result)
│  │  └─ downloadDocument(blob)
│  │
│  ├─ UI组件
│  │  ├─ showParsingProgress()
│  │  ├─ showAnalysisResult()
│  │  ├─ showResultImportPanel()
│  │  └─ showDownloadSuccess()
│  │
│  └─ 事件处理
│     ├─ 文件选择
│     ├─ 模式选择
│     └─ 立场选择
│
├─ utils.js (通用工具库)
│ ├─ FileHandler - 统一的文件选择和验证
│ ├─ ApiClient - 统一的API调用
│ ├─ UiHelper - 统一的UI操作
│ ├─ StateManager - 统一的状态管理
│ └─ Logger - 统一的日志
│
├─ review-mode-handlers.js (审查方式处理)
│ ├─ RuleModeHandler - 规则审查特定逻辑
│ ├─ ChatGPTModeHandler - ChatGPT特定逻辑
│ └─ QwenAutoModeHandler - Qwen一键特定逻辑
│
├─ 删除以下文件:
│ ├─ party-extraction.js (逻辑合并到main.js)
│ ├─ qwen-review.js (逻辑合并到main.js)
│ └─ stance.js (逻辑合并到main.js)
```

### 后端架构

```
src/main/java/com/example/Contract_review/
│
├─ controller/
│ ├─ ReviewController (新的统一接口)
│ │ ├─ POST /api/review/start
│ │ ├─ POST /api/review/import-result
│ │ └─ GET /api/review/status
│ │
│ ├─ ApiReviewController (保留，逐步迁移)
│ │ ├─ @Deprecated 标记旧接口
│ │ └─ 重定向到新接口
│ │
│ ├─ ChatGPTIntegrationController (保留，逐步迁移)
│ └─ QwenRuleReviewController (保留，逐步迁移)
│
├─ service/
│ ├─ ReviewWorkflowService (统一的工作流编排)
│ │ ├─ startReview(ReviewRequest) - 统一入口
│ │ ├─ importResult(ReviewResultRequest) - 统一导入
│ │ └─ getStatus() - 状态检查
│ │
│ ├─ ReviewParsingService (统一的解析)
│ │ ├─ parseContractWithAnchors(file)
│ │ ├─ extractPartyInfo(parseResult)
│ │ └─ identifyContractType(parseResult)
│ │
│ ├─ ReviewAnalysisService (统一的分析)
│ │ ├─ analyzeWithRules(context) - 规则审查
│ │ ├─ analyzeForChatGPT(context) - ChatGPT提示生成
│ │ └─ analyzeAutomatic(context) - Qwen一键
│ │
│ ├─ ReviewPromptService (统一的Prompt生成)
│ │ ├─ generateRuleReviewPrompt(analysis)
│ │ ├─ generateChatGPTPrompt(analysis)
│ │ └─ generateQwenPrompt(analysis)
│ │
│ ├─ ReviewAnnotationService (统一的批注)
│ │ ├─ annotateDocument(context, issues)
│ │ └─ saveAnnotatedDocument(document, filename, stance)
│ │
│ ├─ QwenRuleReviewService (保留，提供AI审查)
│ ├─ PartyExtractionService (保留，提供党方提取)
│ ├─ RuleMatchingService (可能新增，规则匹配)
│ └─ [其他保留不变]
│
├─ model/
│ ├─ ReviewRequest - 统一的审查请求
│ ├─ ReviewContext - 统一的审查上下文
│ ├─ ReviewAnalysisResult - 统一的分析结果
│ ├─ ReviewResultRequest - 统一的结果导入请求
│ ├─ ReviewMode (enum) - 审查方式
│ └─ ParseWorkflowResult - 解析结果
│
├─ util/
│ ├─ ReviewValidationUtil - 统一的验证
│ ├─ ResponseBuilder - 统一的响应构建
│ ├─ ParseResultCacheManager - 缓存管理
│ └─ JsonParsingUtil - JSON处理
│
└─ config/
  └─ ReviewServiceConfig - 统一的配置
```

---

## 📋 实现步骤

### 第1阶段：后端架构重构

1. **创建统一的数据模型** (1-2小时)
   - ReviewContext
   - ReviewRequest / ReviewResponse
   - ReviewMode enum
   - ParseWorkflowResult

2. **创建统一的服务层** (3-4小时)
   - ReviewParsingService
   - ReviewAnalysisService
   - ReviewPromptService
   - ReviewAnnotationService
   - ReviewWorkflowService

3. **创建新的统一Controller** (1-2小时)
   - ReviewController
   - 实现 /api/review/start, /api/review/import-result

4. **重构旧Controller** (2-3小时)
   - 标记为 @Deprecated
   - 内部重定向到新服务
   - 逐步废弃

5. **编译和单元测试** (1小时)

### 第2阶段：前端架构重构

1. **创建统一的工具库** (1-2小时)
   - utils.js - FileHandler, ApiClient, UiHelper等
   - review-mode-handlers.js - 各模式的特定逻辑

2. **重构main.js** (2-3小时)
   - 迁移所有业务逻辑
   - 删除重复代码
   - 统一状态管理

3. **更新UI交互** (1小时)
   - 更新HTML中的事件绑定
   - 确保所有按钮连接到新逻辑

4. **删除旧文件** (30分钟)
   - party-extraction.js
   - qwen-review.js
   - stance.js

5. **端到端测试** (1小时)

### 第3阶段：验证和文档

1. **编译验证** (30分钟)
   - mvn clean compile
   - mvn clean package
   - BUILD SUCCESS 确认

2. **功能测试** (1-2小时)
   - 规则审查流程完整测试
   - ChatGPT流程完整测试
   - 一键审查流程完整测试

3. **回归测试** (1小时)
   - 所有现有功能仍可用
   - 向后兼容性确认

4. **生成文档** (1小时)
   - 架构设计文档
   - API升级指南
   - 迁移指南

---

## 🎯 预期收益

### 代码质量

| 指标 | 改进前 | 改进后 | 减少 |
|------|--------|--------|------|
| JS文件数 | 3 | 2 | 33% |
| JS代码行数 | 2503 | 1700 | 32% |
| Service类数 | ~10 | ~15 | +50% (但更清晰) |
| 代码重复率 | ~25% | ~5% | 80% 减少 |
| 测试覆盖率 | ~30% | ~70% | +40% |

### 可维护性

- ✅ **消除了parseResultId变量命名混乱** - 统一在ReviewContext中管理
- ✅ **消除了三套重复的工作流** - 统一为一套，参数化方式变化
- ✅ **消除了散落的加载动画操作** - 统一为UiHelper.showLoading()
- ✅ **消除了文件选择处理重复** - 统一为FileHandler.selectFile()
- ✅ **容易添加新的LLM方式** - 只需添加新的AnalysisHandler

### 问题防止

- 🛡️ **parseResultId丢失问题** - 统一在ReviewContext中传递，不会丢失
- 🛡️ **批注缺少锚点问题** - ReviewContext确保始终使用正确的parseResultId
- 🛡️ **立场处理不一致** - 统一在ReviewAnalysisService中处理
- 🛡️ **错误的变量名** - 不再有多个变量名，只有一个ReviewContext

---

## 📝 总结

这个统一架构设计的核心思想是：

> **一个工作流（ReviewWorkflow）+ 一个上下文（ReviewContext）+ N种执行策略（RuleModeHandler, ChatGPTModeHandler等）**

通过这个设计，我们可以：
1. **消除代码重复** - 从三套工作流变为一套
2. **防止问题复现** - parseResultId统一管理，不会丢失
3. **易于扩展** - 添加新的审查方式只需新增Handler
4. **易于维护** - 清晰的分层和职责划分
5. **易于测试** - 每个Service可独立测试

这就是你要的"简化代码，统一功能接口，防止这类问题发生"！

