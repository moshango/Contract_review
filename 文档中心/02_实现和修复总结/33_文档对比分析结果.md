# 文档对比分析结果

## 对比发现

### 关键差异

**MinIO下载的文档缺少批注文件！**

1. **缺少 `word/comments.xml`**
   - 本地文档：存在（7988 字节，包含7个批注）
   - MinIO文档：❌ 不存在

2. **缺少 `word/_rels/document.xml.rels` 中的comments关系**
   - 本地文档：包含 `rComments: comments -> comments.xml`
   - MinIO文档：❌ 不包含comments关系

3. **文件大小差异**
   - 本地：38046 字节
   - MinIO：31959 字节
   - 差异：6087 字节（正好接近comments.xml的大小）

4. **MD5不同**
   - 本地：`365d269fbc837a98494587387101bf6d`
   - MinIO：`669131de9265b6baa4470cd5271e0d27`
   - 说明是两个完全不同的文档

5. **文件数量差异**
   - 本地：19 个文件
   - MinIO：17 个文件
   - MinIO缺少：comments.xml, numbering.xml, customXml相关文件等

## 问题根源分析

### 代码检查

从 `QwenRuleReviewController.java` 看，上传逻辑是正确的：

```java
// 步骤5：生成带批注的文档
byte[] annotatedDocBytes = xmlContractAnnotateService.annotateContractWithXml(
    documentWithAnchorBytes, issues, "preferAnchor", false);

// 步骤6：保存到本地
Files.write(outputPath, annotatedDocBytes);

// 步骤7：上传到MinIO
minioUrl = minioFileService.uploadBytes(
    annotatedDocBytes,  // ← 应该是带批注的文档
    minioObjectName,
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
);
```

**代码看起来正确，应该上传的是 `annotatedDocBytes`（带批注的文档）。**

### 可能的原因

#### 1. MinIO中存储的是旧版本的文档

**可能性**：MinIO中的文档可能是在某个早期步骤上传的，而不是最终带批注的版本。

**检查点**：
- 是否在批注生成之前就上传了文档？
- 是否有多个地方上传文档到MinIO？

#### 2. objectName冲突导致覆盖

**可能性**：如果 `generateReportObjectName` 生成的objectName相同，可能会导致新文档覆盖旧文档。

**检查点**：
```java
String minioObjectName = minioFileService.generateReportObjectName(
    filename, "一键审查", stance);
```
- UUID是否每次都不同？
- 时间戳是否唯一？

#### 3. MinIO存储时文档被修改

**可能性**：MinIO在存储时可能对文档进行了某些处理。

**检查点**：
- MinIO配置是否正确？
- 上传时的ContentType是否正确？

#### 4. 下载时获取了错误的文档

**可能性**：下载时使用了错误的objectName。

**检查点**：
- 下载时使用的objectName是否正确？
- 是否下载了其他版本的文档？

## 验证步骤

### 步骤1：检查日志中的MD5

从日志查看：
```
【诊断】上传前文档MD5: {hash1}
【诊断】下载后文档MD5: {hash2}
```

如果MD5不匹配，说明上传和下载的不是同一个文档。

### 步骤2：检查objectName生成逻辑

查看 `generateReportObjectName` 方法：
```java
public String generateReportObjectName(String originalFilename, String reviewType, String stance) {
    String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
    String uuid = UUID.randomUUID().toString().substring(0, 8);
    String cleanBaseName = baseName.replaceAll("[^a-zA-Z0-9._-]", "_");
    return String.format("%s/%s_%s_%s_%s_%s.docx", 
                       path, cleanBaseName, reviewType, stance, timestamp, uuid);
}
```

确保每次生成的objectName都是唯一的。

### 步骤3：检查是否有其他地方上传文档

检查代码中是否还有其他地方上传文档到MinIO：
- 规则未命中时上传的文档
- 原始文档上传
- 其他审查流程上传的文档

## 解决方案

### 方案1：确保上传的是正确的文档

在 `uploadBytes` 调用前添加验证：

```java
// 验证文档是否包含批注
boolean hasComments = validateDocHasComments(annotatedDocBytes);
if (!hasComments) {
    log.error("⚠️ 警告：准备上传的文档不包含批注！");
}

minioUrl = minioFileService.uploadBytes(
    annotatedDocBytes, 
    minioObjectName,
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
);
```

### 方案2：添加上传后验证

在上传后立即下载并验证：

```java
// 上传后立即下载验证
byte[] downloaded = minioFileService.downloadFile(minioObjectName);
boolean hasComments = validateDocHasComments(downloaded);
if (!hasComments) {
    log.error("⚠️ 警告：MinIO中的文档不包含批注！可能上传失败或被覆盖");
}
```

### 方案3：使用更详细的日志

在上传和下载时记录更多信息：

```java
log.info("【详细诊断】上传文档: size={}, objectName={}, MD5={}", 
         annotatedDocBytes.length, minioObjectName, md5BeforeStr);
```

## 立即行动

### 1. 查看最近的日志

检查日志中的MD5信息：
- 上传前的MD5
- 下载后的MD5
- 是否匹配

### 2. 检查objectName

查看日志中的objectName是否每次都不一样。

### 3. 重新测试

重新生成一个文档，立即下载并对比：
- 上传前文档的内容
- 下载后文档的内容
- MD5是否匹配

---

**问题状态**：⚠️ 严重 - MinIO文档缺少批注文件  
**下一步**：检查日志中的MD5和objectName，确认问题根源  
**修复优先级**：高 - 需要立即修复


