# 精确文字范围批注改进方案

**问题**: 当前批注是按整行（Run）插入的，不是按匹配的文字范围插入

**现象**:
```
日志: 找到匹配文字：位置=3, 长度=34, 索引=1/1
结果: 整个Run都被批注了（位置3-37，长度34+3=37）
期望: 只批注位置3-37的这34个字符
```

---

## 🔍 问题根源分析

### 当前实现的流程

```
1. PreciseTextAnnotationLocator 找到匹配范围
   └─ 返回: startRun, endRun, startOffsetInRun, endOffsetInRun
   └─ 例如: startRun=Run0, startOffset=3, endRun=Run0, endOffset=37

2. WordXmlCommentProcessor.insertPreciseCommentRange()
   └─ 在 Run 前插入 commentRangeStart
   └─ 在 Run 后插入 commentRangeEnd
   └─ ❌ 结果: 整个 Run 都被批注了
```

### 为什么会这样？

Word XML 的批注标记是 **段落级别** 的，不能在Run内部精确插入。解决方案是：
- 当匹配的文字在单个Run内部时，需要**分割Run**
- 将Run分成：前缀、匹配部分、后缀三部分
- 只在匹配部分前后插入批注标记

---

## 💡 改进方案

### 方案 A: Run分割法（推荐）⭐

**原理**:
```
原Run文本: "1. 本合同未尽事宜，双方可签署补充协议，补充协议与本合同具有同等法律效力。"
          (位置0                  3|←----34个字符---->|37)

分割后:
  Run1: "1. "                           (保留)
  Run2: "本合同未尽事宜，双方可签署补充协议，补充协议与本合同具有同等法律效力"  (新Run，用于批注)
  Run3: "。"                           (保留)

批注标记放在 Run2 前后
```

**优点**:
- 精确控制批注范围
- Word能正确显示
- 用户可以清晰看到批注的具体位置

**缺点**:
- 需要修改Run元素结构
- 代码复杂度增加
- 需要处理多个Run跨越的情况

**工作流**:
```java
private void insertPreciseCommentRangeWithRunSplit(
    Element paragraph,
    Element startRun,
    int startOffsetInRun,
    Element endRun,
    int endOffsetInRun,
    int commentId) {

    // 1. 如果是同一个Run内部
    if (startRun == endRun) {
        // 分割Run成三部分
        String originalText = extractRunText(startRun);

        // 前缀: 0 ~ startOffset
        String prefix = originalText.substring(0, startOffsetInRun);

        // 匹配部分: startOffset ~ endOffset
        String matched = originalText.substring(startOffsetInRun, endOffsetInRun);

        // 后缀: endOffset ~ 末尾
        String suffix = originalText.substring(endOffsetInRun);

        // 清空原Run
        startRun.clearContent();

        // 如果有前缀，创建前缀Run
        if (!prefix.isEmpty()) {
            createRunWithText(paragraph, prefix, startRun);
        }

        // 创建新Run用于批注（包含匹配部分）
        Element newRun = createNewRun(paragraph);
        setRunText(newRun, matched);

        // 在新Run前后插入批注标记
        insertCommentRangeStart(paragraph, newRun, commentId);
        insertCommentRangeEnd(paragraph, newRun, commentId);

        // 如果有后缀，创建后缀Run
        if (!suffix.isEmpty()) {
            createRunWithText(paragraph, suffix, startRun);
        }
    }
    // 2. 如果跨越多个Run，处理更复杂...
}
```

### 方案 B: 段落级别退回法

**原理**: 当文字跨越多个Run，或分割过于复杂时，退回到段落级别批注

**优点**:
- 简单，不改动Run结构
- 避免复杂边界情况

**缺点**:
- 失去精确定位的优势
- 整段都被批注

### 方案 C: 混合法（最实用）✅

结合方案A和B：
- **情况1**: 单个Run内匹配 → 使用方案A（分割Run）
- **情况2**: 跨多个Run匹配 → 使用方案B（段落级别）
- **情况3**: 匹配失败 → 使用段落级别（已有）

---

## 📋 实现步骤（推荐按此顺序）

### 第1步: 增强 TextMatchResult 类

添加字段用于存储Run内偏移量：

```java
public class TextMatchResult {
    // 现有字段
    private Element startRun;
    private Element endRun;
    private int startPosition;
    private int endPosition;

    // 新增字段
    private int startOffsetInRun;  // Run内起始偏移
    private int endOffsetInRun;    // Run内结束偏移
    private boolean isSingleRun;   // 是否在单个Run内

    // getter/setter...
}
```

### 第2步: 修改 PreciseTextAnnotationLocator

在 `mapPositionToRuns()` 方法中计算Run内偏移量：

```java
// 现有代码已计算了 startOffsetInRun 和 endOffsetInRun
// 只需添加以下逻辑：

if (startRun == endRun) {
    result.setIsSingleRun(true);
} else {
    result.setIsSingleRun(false);
}

logger.debug("是否单Run内: {}, startOffset={}, endOffset={}",
           result.isSingleRun(), startOffsetInRun, endOffsetInRun);
```

### 第3步: 修改 WordXmlCommentProcessor

改进 `insertPreciseCommentRange()` 方法：

```java
private void insertPreciseCommentRange(
    Element paragraph,
    TextMatchResult matchResult,
    int commentId) {

    // 情况1: 单个Run内的匹配 - 分割Run
    if (matchResult.isSingleRun()) {
        insertPreciseCommentRangeInSingleRun(
            paragraph,
            matchResult,
            commentId);
    }
    // 情况2: 多个Run跨越 - 段落级别
    else {
        logger.debug("匹配跨越多个Run，降级到段落级别批注");
        insertCommentRangeInDocument(paragraph, commentId);
    }
}
```

### 第4步: 实现 Run 分割逻辑

```java
private void insertPreciseCommentRangeInSingleRun(
    Element paragraph,
    TextMatchResult matchResult,
    int commentId) {

    Element originalRun = matchResult.getStartRun();
    int startOffset = matchResult.getStartOffsetInRun();
    int endOffset = matchResult.getEndOffsetInRun();

    // 提取原Run的文本和属性
    String originalText = extractRunText(originalRun);
    String prefix = originalText.substring(0, startOffset);
    String matched = originalText.substring(startOffset, endOffset);
    String suffix = originalText.substring(endOffset);

    // 获取Run在段落中的位置
    List<Element> allRuns = paragraph.elements(QName.get("r", W_NS));
    int runIndex = allRuns.indexOf(originalRun);

    // 清空原Run
    originalRun.clearContent();

    // 1. 前缀Run（如果有）
    if (!prefix.isEmpty()) {
        Element prefixRun = new org.dom4j.tree.DefaultElement(QName.get("r", W_NS));
        setRunText(prefixRun, prefix);
        paragraph.elements().add(runIndex, prefixRun);
        runIndex++;
    }

    // 2. 匹配部分Run - 这个Run会被批注
    Element matchedRun = new org.dom4j.tree.DefaultElement(QName.get("r", W_NS));
    setRunText(matchedRun, matched);

    // 在matchedRun前插入commentRangeStart
    Element rangeStart = new org.dom4j.tree.DefaultElement(QName.get("commentRangeStart", W_NS));
    rangeStart.addAttribute(QName.get("id", W_NS), String.valueOf(commentId));
    paragraph.elements().add(runIndex, rangeStart);
    runIndex++;

    // 添加matchedRun
    paragraph.elements().add(runIndex, matchedRun);
    runIndex++;

    // 在matchedRun后插入commentRangeEnd
    Element rangeEnd = new org.dom4j.tree.DefaultElement(QName.get("commentRangeEnd", W_NS));
    rangeEnd.addAttribute(QName.get("id", W_NS), String.valueOf(commentId));
    paragraph.elements().add(runIndex, rangeEnd);
    runIndex++;

    // 3. 后缀Run（如果有）
    if (!suffix.isEmpty()) {
        Element suffixRun = new org.dom4j.tree.DefaultElement(QName.get("r", W_NS));
        setRunText(suffixRun, suffix);
        paragraph.elements().add(runIndex, suffixRun);
    }

    logger.debug("Run分割完成：前缀={}, 匹配={}, 后缀={}",
               prefix.length(), matched.length(), suffix.length());
}
```

---

## 🧪 测试计划

### 测试用例1: 单Run内匹配（最常见）
```
段落: "1. 本合同未尽事宜，双方可签署补充协议，补充协议与本合同具有同等法律效力。"
匹配: "本合同未尽事宜，双方可签署补充协议，补充协议与本合同具有同等法律效力"
预期: 只有匹配部分被批注，不包括"1. "和"。"
```

### 测试用例2: 多Run匹配（降级处理）
```
跨越多个Run → 降级到段落级别 → 整段被批注（可接受）
```

### 测试用例3: 边界情况
```
- 匹配从Run开头开始
- 匹配到Run末尾
- 匹配就是整个Run
```

---

## 📊 影响范围

**需要修改的文件**:
1. `TextMatchResult.java` - 添加字段（小改）
2. `PreciseTextAnnotationLocator.java` - 计算偏移（小改）
3. `WordXmlCommentProcessor.java` - 核心逻辑（大改）

**不需要修改**:
- JSON配置（annotate_PRECISE_FIXED.json）- 不变
- PreciseTextAnnotationLocator的匹配逻辑 - 继续使用

---

## ⏱️ 实现时间估计

- 第1步: 10分钟
- 第2步: 15分钟
- 第3步: 30分钟
- 第4步: 45分钟
- 测试调试: 30分钟
- **总计: 2-3小时**

---

## 🎯 优先级

**高优先级** - 如果希望精确定位真正有效
- 实现方案C（混合法）
- 至少处理单Run内匹配的情况

**低优先级** - 如果当前段落级别批注已可接受
- 可保持现状，不做改进

---

## ✅ 推荐方案

**使用方案 C（混合法）**：
1. ✅ 实现 Run 分割逻辑（处理单Run内匹配）
2. ✅ 多Run匹配时自动降级
3. ✅ 匹配失败时保持现有降级逻辑
4. ✅ 确保系统稳定，逐步优化

这样既能实现精确定位，又不会引入过多复杂性。

